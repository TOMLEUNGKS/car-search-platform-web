import {
  matchedRouteKey,
  routeLocationKey,
  useRoute
} from "./chunk-3R6TLUG4.js";
import "./chunk-FVZHS5AO.js";
import {
  IonicSafeString,
  IonicSlides,
  IonicSwiper,
  actionSheetController,
  alertController,
  defineCustomElement,
  defineCustomElement10,
  defineCustomElement11,
  defineCustomElement12,
  defineCustomElement13,
  defineCustomElement14,
  defineCustomElement15,
  defineCustomElement16,
  defineCustomElement17,
  defineCustomElement18,
  defineCustomElement19,
  defineCustomElement2,
  defineCustomElement20,
  defineCustomElement21,
  defineCustomElement22,
  defineCustomElement23,
  defineCustomElement24,
  defineCustomElement25,
  defineCustomElement26,
  defineCustomElement27,
  defineCustomElement28,
  defineCustomElement29,
  defineCustomElement3,
  defineCustomElement30,
  defineCustomElement31,
  defineCustomElement32,
  defineCustomElement33,
  defineCustomElement34,
  defineCustomElement35,
  defineCustomElement36,
  defineCustomElement37,
  defineCustomElement38,
  defineCustomElement39,
  defineCustomElement4,
  defineCustomElement40,
  defineCustomElement41,
  defineCustomElement42,
  defineCustomElement43,
  defineCustomElement44,
  defineCustomElement45,
  defineCustomElement46,
  defineCustomElement47,
  defineCustomElement48,
  defineCustomElement49,
  defineCustomElement5,
  defineCustomElement50,
  defineCustomElement51,
  defineCustomElement52,
  defineCustomElement53,
  defineCustomElement54,
  defineCustomElement55,
  defineCustomElement56,
  defineCustomElement57,
  defineCustomElement58,
  defineCustomElement59,
  defineCustomElement6,
  defineCustomElement60,
  defineCustomElement61,
  defineCustomElement62,
  defineCustomElement63,
  defineCustomElement64,
  defineCustomElement65,
  defineCustomElement66,
  defineCustomElement67,
  defineCustomElement68,
  defineCustomElement69,
  defineCustomElement7,
  defineCustomElement70,
  defineCustomElement71,
  defineCustomElement72,
  defineCustomElement73,
  defineCustomElement74,
  defineCustomElement75,
  defineCustomElement76,
  defineCustomElement78 as defineCustomElement77,
  defineCustomElement79 as defineCustomElement78,
  defineCustomElement8,
  defineCustomElement80 as defineCustomElement79,
  defineCustomElement84 as defineCustomElement80,
  defineCustomElement89 as defineCustomElement81,
  defineCustomElement9,
  defineCustomElement92 as defineCustomElement82,
  defineCustomElement93 as defineCustomElement83,
  defineCustomElement95 as defineCustomElement84,
  getPlatforms,
  getTimeGivenProgression,
  initialize,
  isPlatform,
  loadingController,
  menuController,
  modalController,
  pickerController,
  popoverController,
  toastController
} from "./chunk-Y5B7A5CJ.js";
import "./chunk-VP4VB3QY.js";
import "./chunk-CANELBXE.js";
import "./chunk-XZPNADHU.js";
import "./chunk-EAFRSHXE.js";
import {
  iosTransitionAnimation
} from "./chunk-DAIAMDRD.js";
import {
  mdTransitionAnimation
} from "./chunk-6DUQWYFA.js";
import {
  LIFECYCLE_DID_ENTER,
  LIFECYCLE_DID_LEAVE,
  LIFECYCLE_WILL_ENTER,
  LIFECYCLE_WILL_LEAVE,
  createAnimation
} from "./chunk-JXYWZCAT.js";
import {
  Build,
  H,
  Host,
  getAssetPath,
  h as h2,
  proxyCustomElement
} from "./chunk-QDADS6F7.js";
import "./chunk-Q3XGFCCA.js";
import {
  createGesture
} from "./chunk-NKPPOIKL.js";
import "./chunk-IWZSYLON.js";
import "./chunk-VGC2NAOA.js";
import {
  Teleport,
  computed,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  onMounted,
  onUnmounted,
  provide,
  ref,
  shallowRef,
  watch
} from "./chunk-AWD2DKKE.js";
import "./chunk-J43GMYXM.js";

// node_modules/ionicons/components/ion-icon.js
var CACHED_MAP;
var getIconMap = () => {
  if (typeof window === "undefined") {
    return /* @__PURE__ */ new Map();
  } else {
    if (!CACHED_MAP) {
      const win = window;
      win.Ionicons = win.Ionicons || {};
      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || /* @__PURE__ */ new Map();
    }
    return CACHED_MAP;
  }
};
var getUrl = (i) => {
  let url = getSrc(i.src);
  if (url) {
    return url;
  }
  url = getName(i.name, i.icon, i.mode, i.ios, i.md);
  if (url) {
    return getNamedUrl(url);
  }
  if (i.icon) {
    url = getSrc(i.icon);
    if (url) {
      return url;
    }
    url = getSrc(i.icon[i.mode]);
    if (url) {
      return url;
    }
  }
  return null;
};
var getNamedUrl = (iconName) => {
  const url = getIconMap().get(iconName);
  if (url) {
    return url;
  }
  return getAssetPath(`svg/${iconName}.svg`);
};
var getName = (iconName, icon, mode, ios, md) => {
  mode = (mode && toLower(mode)) === "ios" ? "ios" : "md";
  if (ios && mode === "ios") {
    iconName = toLower(ios);
  } else if (md && mode === "md") {
    iconName = toLower(md);
  } else {
    if (!iconName && icon && !isSrc(icon)) {
      iconName = icon;
    }
    if (isStr(iconName)) {
      iconName = toLower(iconName);
    }
  }
  if (!isStr(iconName) || iconName.trim() === "") {
    return null;
  }
  const invalidChars = iconName.replace(/[a-z]|-|\d/gi, "");
  if (invalidChars !== "") {
    return null;
  }
  return iconName;
};
var getSrc = (src) => {
  if (isStr(src)) {
    src = src.trim();
    if (isSrc(src)) {
      return src;
    }
  }
  return null;
};
var isSrc = (str) => str.length > 0 && /(\/|\.)/.test(str);
var isStr = (val) => typeof val === "string";
var toLower = (val) => val.toLowerCase();
var inheritAttributes = (el, attributes = []) => {
  const attributeObject = {};
  attributes.forEach((attr) => {
    if (el.hasAttribute(attr)) {
      const value = el.getAttribute(attr);
      if (value !== null) {
        attributeObject[attr] = el.getAttribute(attr);
      }
      el.removeAttribute(attr);
    }
  });
  return attributeObject;
};
var isRTL = (hostEl) => {
  if (hostEl) {
    if (hostEl.dir !== "") {
      return hostEl.dir.toLowerCase() === "rtl";
    }
  }
  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === "rtl";
};
var validateContent = (svgContent) => {
  const div = document.createElement("div");
  div.innerHTML = svgContent;
  for (let i = div.childNodes.length - 1; i >= 0; i--) {
    if (div.childNodes[i].nodeName.toLowerCase() !== "svg") {
      div.removeChild(div.childNodes[i]);
    }
  }
  const svgElm = div.firstElementChild;
  if (svgElm && svgElm.nodeName.toLowerCase() === "svg") {
    const svgClass = svgElm.getAttribute("class") || "";
    svgElm.setAttribute("class", (svgClass + " s-ion-icon").trim());
    if (isValid(svgElm)) {
      return div.innerHTML;
    }
  }
  return "";
};
var isValid = (elm) => {
  if (elm.nodeType === 1) {
    if (elm.nodeName.toLowerCase() === "script") {
      return false;
    }
    for (let i = 0; i < elm.attributes.length; i++) {
      const name = elm.attributes[i].name;
      if (isStr(name) && name.toLowerCase().indexOf("on") === 0) {
        return false;
      }
    }
    for (let i = 0; i < elm.childNodes.length; i++) {
      if (!isValid(elm.childNodes[i])) {
        return false;
      }
    }
  }
  return true;
};
var ioniconContent = /* @__PURE__ */ new Map();
var requests = /* @__PURE__ */ new Map();
var getSvgContent = (url, sanitize) => {
  let req = requests.get(url);
  if (!req) {
    if (typeof fetch !== "undefined" && typeof document !== "undefined") {
      req = fetch(url).then((rsp) => {
        if (rsp.ok) {
          return rsp.text().then((svgContent) => {
            if (svgContent && sanitize !== false) {
              svgContent = validateContent(svgContent);
            }
            ioniconContent.set(url, svgContent || "");
          });
        }
        ioniconContent.set(url, "");
      });
      requests.set(url, req);
    } else {
      ioniconContent.set(url, "");
      return Promise.resolve();
    }
  }
  return req;
};
var iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";
var parser;
var Icon = proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.iconName = null;
    this.inheritedAttributes = {};
    this.isVisible = false;
    this.mode = getIonMode();
    this.lazy = false;
    this.sanitize = true;
    this.hasAriaHidden = () => {
      const { el } = this;
      return el.hasAttribute("aria-hidden") && el.getAttribute("aria-hidden") === "true";
    };
  }
  componentWillLoad() {
    this.inheritedAttributes = inheritAttributes(this.el, ["aria-label"]);
  }
  connectedCallback() {
    this.waitUntilVisible(this.el, "50px", () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = void 0;
    }
  }
  waitUntilVisible(el, rootMargin, cb) {
    if (Build.isBrowser && this.lazy && typeof window !== "undefined" && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data) => {
        if (data[0].isIntersecting) {
          io.disconnect();
          this.io = void 0;
          cb();
        }
      }, { rootMargin });
      io.observe(el);
    } else {
      cb();
    }
  }
  loadIcon() {
    if (Build.isBrowser && this.isVisible) {
      if (!parser) {
        parser = new DOMParser();
      }
      const url = getUrl(this);
      if (url) {
        if (ioniconContent.has(url)) {
          this.svgContent = ioniconContent.get(url);
        } else if (url.startsWith("data:")) {
          const doc = parser.parseFromString(url, "text/html");
          const svgEl = doc.body.querySelector("svg");
          if (svgEl !== null) {
            this.svgContent = svgEl.outerHTML;
          } else {
            this.svgContent = "";
          }
        } else {
          getSvgContent(url, this.sanitize).then(() => this.svgContent = ioniconContent.get(url));
        }
      }
    }
    const label = this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md);
    if (label) {
      this.ariaLabel = label.replace(/\-/g, " ");
    }
  }
  render() {
    const { iconName, ariaLabel, el, inheritedAttributes } = this;
    const mode = this.mode || "md";
    const flipRtl = this.flipRtl || iconName && (iconName.indexOf("arrow") > -1 || iconName.indexOf("chevron") > -1) && this.flipRtl !== false;
    return h2(Host, Object.assign({ "aria-label": ariaLabel !== void 0 && !this.hasAriaHidden() ? ariaLabel : null, role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, "flip-rtl": !!flipRtl && isRTL(el) }) }, inheritedAttributes), Build.isBrowser && this.svgContent ? h2("div", { class: "icon-inner", innerHTML: this.svgContent }) : h2("div", { class: "icon-inner" }));
  }
  static get assetsDirs() {
    return ["svg"];
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      "name": ["loadIcon"],
      "src": ["loadIcon"],
      "icon": ["loadIcon"]
    };
  }
  static get style() {
    return iconCss;
  }
}, [1, "ion-icon", {
  "mode": [1025],
  "color": [1],
  "ios": [1],
  "md": [1],
  "flipRtl": [4, "flip-rtl"],
  "name": [513],
  "src": [1],
  "icon": [8],
  "size": [1],
  "lazy": [4],
  "sanitize": [4],
  "svgContent": [32],
  "isVisible": [32],
  "ariaLabel": [32]
}]);
var getIonMode = () => Build.isBrowser && typeof document !== "undefined" && document.documentElement.getAttribute("mode") || "md";
var createColorClasses = (color) => {
  return color ? {
    "ion-color": true,
    [`ion-color-${color}`]: true
  } : null;
};
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ion-icon"];
  components.forEach((tagName) => {
    switch (tagName) {
      case "ion-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon);
        }
        break;
    }
  });
}
var defineCustomElement85 = defineCustomElement$1;

// node_modules/@ionic/vue/dist/index.esm.js
var UPDATE_VALUE_EVENT = "update:modelValue";
var MODEL_VALUE = "modelValue";
var ROUTER_LINK_VALUE = "routerLink";
var NAV_MANAGER = "navManager";
var ROUTER_PROP_PREFIX = "router";
var EMPTY_PROP = Symbol();
var DEFAULT_EMPTY_PROP = { default: EMPTY_PROP };
var getComponentClasses = (classes) => {
  return (classes === null || classes === void 0 ? void 0 : classes.split(" ")) || [];
};
var getElementClasses = (ref2, componentClasses, defaultClasses = []) => {
  var _a;
  return [...Array.from(((_a = ref2.value) === null || _a === void 0 ? void 0 : _a.classList) || []), ...defaultClasses].filter((c, i, self) => !componentClasses.has(c) && self.indexOf(c) === i);
};
var defineContainer = (name, defineCustomElement86, componentProps = [], modelProp, modelUpdateEvent, externalModelUpdateEvent) => {
  if (defineCustomElement86 !== void 0) {
    defineCustomElement86();
  }
  const Container = defineComponent((props, { attrs, slots, emit }) => {
    var _a;
    let modelPropValue = props[modelProp];
    const containerRef = ref();
    const classes = new Set(getComponentClasses(attrs.class));
    const onVnodeBeforeMount = (vnode) => {
      if (vnode.el) {
        const eventsNames = Array.isArray(modelUpdateEvent) ? modelUpdateEvent : [modelUpdateEvent];
        eventsNames.forEach((eventName) => {
          vnode.el.addEventListener(eventName.toLowerCase(), (e) => {
            modelPropValue = (e === null || e === void 0 ? void 0 : e.target)[modelProp];
            emit(UPDATE_VALUE_EVENT, modelPropValue);
            if (externalModelUpdateEvent) {
              emit(externalModelUpdateEvent, e);
            }
          });
        });
      }
    };
    const currentInstance = getCurrentInstance();
    const hasRouter = (_a = currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.appContext) === null || _a === void 0 ? void 0 : _a.provides[NAV_MANAGER];
    const navManager = hasRouter ? inject(NAV_MANAGER) : void 0;
    const handleRouterLink = (ev) => {
      const { routerLink } = props;
      if (routerLink === EMPTY_PROP)
        return;
      if (navManager !== void 0) {
        let navigationPayload = { event: ev };
        for (const key in props) {
          const value = props[key];
          if (props.hasOwnProperty(key) && key.startsWith(ROUTER_PROP_PREFIX) && value !== EMPTY_PROP) {
            navigationPayload[key] = value;
          }
        }
        navManager.navigate(navigationPayload);
      } else {
        console.warn("Tried to navigate, but no router was found. Make sure you have mounted Vue Router.");
      }
    };
    return () => {
      modelPropValue = props[modelProp];
      getComponentClasses(attrs.class).forEach((value) => {
        classes.add(value);
      });
      const oldClick = props.onClick;
      const handleClick = (ev) => {
        if (oldClick !== void 0) {
          oldClick(ev);
        }
        if (!ev.defaultPrevented) {
          handleRouterLink(ev);
        }
      };
      let propsToAdd = {
        ref: containerRef,
        class: getElementClasses(containerRef, classes),
        onClick: handleClick,
        onVnodeBeforeMount: modelUpdateEvent ? onVnodeBeforeMount : void 0
      };
      for (const key in props) {
        const value = props[key];
        if (props.hasOwnProperty(key) && value !== EMPTY_PROP) {
          propsToAdd[key] = value;
        }
      }
      if (modelProp) {
        if (props[MODEL_VALUE] !== EMPTY_PROP) {
          propsToAdd = Object.assign(Object.assign({}, propsToAdd), { [modelProp]: props[MODEL_VALUE] });
        } else if (modelPropValue !== EMPTY_PROP) {
          propsToAdd = Object.assign(Object.assign({}, propsToAdd), { [modelProp]: modelPropValue });
        }
      }
      return h(name, propsToAdd, slots.default && slots.default());
    };
  });
  Container.displayName = name;
  Container.props = {
    [ROUTER_LINK_VALUE]: DEFAULT_EMPTY_PROP
  };
  componentProps.forEach((componentProp) => {
    Container.props[componentProp] = DEFAULT_EMPTY_PROP;
  });
  if (modelProp) {
    Container.props[MODEL_VALUE] = DEFAULT_EMPTY_PROP;
    Container.emits = [UPDATE_VALUE_EVENT, externalModelUpdateEvent];
  }
  return Container;
};
var IonAccordion = defineContainer("ion-accordion", defineCustomElement, [
  "value",
  "disabled",
  "readonly",
  "toggleIcon",
  "toggleIconSlot"
]);
var IonAccordionGroup = defineContainer("ion-accordion-group", defineCustomElement2, [
  "animated",
  "multiple",
  "value",
  "disabled",
  "readonly",
  "expand",
  "ionChange"
], "value", "v-ion-change", "ionChange");
var IonAvatar = defineContainer("ion-avatar", defineCustomElement3);
var IonBackdrop = defineContainer("ion-backdrop", defineCustomElement4, [
  "visible",
  "tappable",
  "stopPropagation",
  "ionBackdropTap"
]);
var IonBadge = defineContainer("ion-badge", defineCustomElement5, [
  "color"
]);
var IonBreadcrumb = defineContainer("ion-breadcrumb", defineCustomElement6, [
  "collapsed",
  "last",
  "showCollapsedIndicator",
  "color",
  "active",
  "disabled",
  "download",
  "href",
  "rel",
  "separator",
  "target",
  "routerDirection",
  "routerAnimation",
  "ionFocus",
  "ionBlur",
  "collapsedClick"
]);
var IonBreadcrumbs = defineContainer("ion-breadcrumbs", defineCustomElement7, [
  "color",
  "maxItems",
  "itemsBeforeCollapse",
  "itemsAfterCollapse",
  "ionCollapsedClick"
]);
var IonButton = defineContainer("ion-button", defineCustomElement8, [
  "color",
  "buttonType",
  "disabled",
  "expand",
  "fill",
  "routerDirection",
  "routerAnimation",
  "download",
  "href",
  "rel",
  "shape",
  "size",
  "strong",
  "target",
  "type",
  "form",
  "ionFocus",
  "ionBlur"
]);
var IonButtons = defineContainer("ion-buttons", defineCustomElement9, [
  "collapse"
]);
var IonCard = defineContainer("ion-card", defineCustomElement10, [
  "color",
  "button",
  "type",
  "disabled",
  "download",
  "href",
  "rel",
  "routerDirection",
  "routerAnimation",
  "target"
]);
var IonCardContent = defineContainer("ion-card-content", defineCustomElement11);
var IonCardHeader = defineContainer("ion-card-header", defineCustomElement12, [
  "color",
  "translucent"
]);
var IonCardSubtitle = defineContainer("ion-card-subtitle", defineCustomElement13, [
  "color"
]);
var IonCardTitle = defineContainer("ion-card-title", defineCustomElement14, [
  "color"
]);
var IonCheckbox = defineContainer("ion-checkbox", defineCustomElement15, [
  "color",
  "name",
  "checked",
  "indeterminate",
  "disabled",
  "value",
  "ionChange",
  "ionFocus",
  "ionBlur",
  "ionStyle"
], "checked", "v-ion-change", "ionChange");
var IonChip = defineContainer("ion-chip", defineCustomElement16, [
  "color",
  "outline",
  "disabled"
]);
var IonCol = defineContainer("ion-col", defineCustomElement17, [
  "offset",
  "offsetXs",
  "offsetSm",
  "offsetMd",
  "offsetLg",
  "offsetXl",
  "pull",
  "pullXs",
  "pullSm",
  "pullMd",
  "pullLg",
  "pullXl",
  "push",
  "pushXs",
  "pushSm",
  "pushMd",
  "pushLg",
  "pushXl",
  "size",
  "sizeXs",
  "sizeSm",
  "sizeMd",
  "sizeLg",
  "sizeXl"
]);
var IonContent = defineContainer("ion-content", defineCustomElement18, [
  "color",
  "fullscreen",
  "forceOverscroll",
  "scrollX",
  "scrollY",
  "scrollEvents",
  "ionScrollStart",
  "ionScroll",
  "ionScrollEnd"
]);
var IonDatetime = defineContainer("ion-datetime", defineCustomElement19, [
  "color",
  "name",
  "disabled",
  "readonly",
  "isDateEnabled",
  "min",
  "max",
  "presentation",
  "cancelText",
  "doneText",
  "clearText",
  "yearValues",
  "monthValues",
  "dayValues",
  "hourValues",
  "minuteValues",
  "locale",
  "firstDayOfWeek",
  "titleSelectedDatesFormatter",
  "multiple",
  "value",
  "showDefaultTitle",
  "showDefaultButtons",
  "showClearButton",
  "showDefaultTimeLabel",
  "hourCycle",
  "size",
  "preferWheel",
  "ionCancel",
  "ionChange",
  "ionFocus",
  "ionBlur",
  "ionStyle",
  "ionRender"
], "value", "v-ion-change", "ionChange");
var IonDatetimeButton = defineContainer("ion-datetime-button", defineCustomElement20, [
  "color",
  "disabled",
  "datetime"
]);
var IonFab = defineContainer("ion-fab", defineCustomElement21, [
  "horizontal",
  "vertical",
  "edge",
  "activated"
]);
var IonFabButton = defineContainer("ion-fab-button", defineCustomElement22, [
  "color",
  "activated",
  "disabled",
  "download",
  "href",
  "rel",
  "routerDirection",
  "routerAnimation",
  "target",
  "show",
  "translucent",
  "type",
  "size",
  "closeIcon",
  "ionFocus",
  "ionBlur"
]);
var IonFabList = defineContainer("ion-fab-list", defineCustomElement23, [
  "activated",
  "side"
]);
var IonFooter = defineContainer("ion-footer", defineCustomElement24, [
  "collapse",
  "translucent"
]);
var IonGrid = defineContainer("ion-grid", defineCustomElement25, [
  "fixed"
]);
var IonHeader = defineContainer("ion-header", defineCustomElement26, [
  "collapse",
  "translucent"
]);
var IonImg = defineContainer("ion-img", defineCustomElement27, [
  "alt",
  "src",
  "ionImgWillLoad",
  "ionImgDidLoad",
  "ionError"
]);
var IonInfiniteScroll = defineContainer("ion-infinite-scroll", defineCustomElement28, [
  "threshold",
  "disabled",
  "position",
  "ionInfinite"
]);
var IonInfiniteScrollContent = defineContainer("ion-infinite-scroll-content", defineCustomElement29, [
  "loadingSpinner",
  "loadingText"
]);
var IonInput = defineContainer("ion-input", defineCustomElement30, [
  "fireFocusEvents",
  "color",
  "accept",
  "autocapitalize",
  "autocomplete",
  "autocorrect",
  "autofocus",
  "clearInput",
  "clearOnEdit",
  "debounce",
  "disabled",
  "enterkeyhint",
  "inputmode",
  "max",
  "maxlength",
  "min",
  "minlength",
  "multiple",
  "name",
  "pattern",
  "placeholder",
  "readonly",
  "required",
  "spellcheck",
  "step",
  "size",
  "type",
  "value",
  "ionInput",
  "ionChange",
  "ionBlur",
  "ionFocus",
  "ionStyle"
], "value", "v-ion-change", "ionChange");
var IonItem = defineContainer("ion-item", defineCustomElement31, [
  "color",
  "button",
  "detail",
  "detailIcon",
  "disabled",
  "download",
  "fill",
  "shape",
  "href",
  "rel",
  "lines",
  "counter",
  "routerAnimation",
  "routerDirection",
  "target",
  "type",
  "counterFormatter"
]);
var IonItemDivider = defineContainer("ion-item-divider", defineCustomElement32, [
  "color",
  "sticky"
]);
var IonItemGroup = defineContainer("ion-item-group", defineCustomElement33);
var IonItemOption = defineContainer("ion-item-option", defineCustomElement34, [
  "color",
  "disabled",
  "download",
  "expandable",
  "href",
  "rel",
  "target",
  "type"
]);
var IonItemOptions = defineContainer("ion-item-options", defineCustomElement35, [
  "side",
  "ionSwipe"
]);
var IonItemSliding = defineContainer("ion-item-sliding", defineCustomElement36, [
  "disabled",
  "ionDrag"
]);
var IonLabel = defineContainer("ion-label", defineCustomElement37, [
  "color",
  "position",
  "ionColor",
  "ionStyle"
]);
var IonList = defineContainer("ion-list", defineCustomElement38, [
  "lines",
  "inset"
]);
var IonListHeader = defineContainer("ion-list-header", defineCustomElement39, [
  "color",
  "lines"
]);
var IonMenu = defineContainer("ion-menu", defineCustomElement40, [
  "contentId",
  "menuId",
  "type",
  "disabled",
  "side",
  "swipeGesture",
  "maxEdgeStart",
  "ionWillOpen",
  "ionWillClose",
  "ionDidOpen",
  "ionDidClose",
  "ionMenuChange"
]);
var IonMenuButton = defineContainer("ion-menu-button", defineCustomElement41, [
  "color",
  "disabled",
  "menu",
  "autoHide",
  "type"
]);
var IonMenuToggle = defineContainer("ion-menu-toggle", defineCustomElement42, [
  "menu",
  "autoHide"
]);
var IonNavLink = defineContainer("ion-nav-link", defineCustomElement44, [
  "component",
  "componentProps",
  "routerDirection",
  "routerAnimation"
]);
var IonNote = defineContainer("ion-note", defineCustomElement45, [
  "color"
]);
var IonProgressBar = defineContainer("ion-progress-bar", defineCustomElement46, [
  "type",
  "reversed",
  "value",
  "buffer",
  "color"
]);
var IonRadio = defineContainer("ion-radio", defineCustomElement47, [
  "color",
  "name",
  "disabled",
  "value",
  "ionStyle",
  "ionFocus",
  "ionBlur"
], "value", "v-ion-change", "ionChange");
var IonRadioGroup = defineContainer("ion-radio-group", defineCustomElement48, [
  "allowEmptySelection",
  "name",
  "value",
  "ionChange"
], "value", "v-ion-change", "ionChange");
var IonRange = defineContainer("ion-range", defineCustomElement49, [
  "color",
  "debounce",
  "name",
  "dualKnobs",
  "min",
  "max",
  "pin",
  "pinFormatter",
  "snaps",
  "step",
  "ticks",
  "activeBarStart",
  "disabled",
  "value",
  "ionChange",
  "ionStyle",
  "ionFocus",
  "ionBlur",
  "ionKnobMoveStart",
  "ionKnobMoveEnd"
], "value", "v-ion-change", "ionChange");
var IonRefresher = defineContainer("ion-refresher", defineCustomElement50, [
  "pullMin",
  "pullMax",
  "closeDuration",
  "snapbackDuration",
  "pullFactor",
  "disabled",
  "ionRefresh",
  "ionPull",
  "ionStart"
]);
var IonRefresherContent = defineContainer("ion-refresher-content", defineCustomElement51, [
  "pullingIcon",
  "pullingText",
  "refreshingSpinner",
  "refreshingText"
]);
var IonReorder = defineContainer("ion-reorder", defineCustomElement52);
var IonReorderGroup = defineContainer("ion-reorder-group", defineCustomElement53, [
  "disabled",
  "ionItemReorder"
]);
var IonRippleEffect = defineContainer("ion-ripple-effect", defineCustomElement54, [
  "type"
]);
var IonRow = defineContainer("ion-row", defineCustomElement55);
var IonSearchbar = defineContainer("ion-searchbar", defineCustomElement56, [
  "color",
  "animated",
  "autocomplete",
  "autocorrect",
  "cancelButtonIcon",
  "cancelButtonText",
  "clearIcon",
  "debounce",
  "disabled",
  "inputmode",
  "enterkeyhint",
  "placeholder",
  "searchIcon",
  "showCancelButton",
  "showClearButton",
  "spellcheck",
  "type",
  "value",
  "ionInput",
  "ionChange",
  "ionCancel",
  "ionClear",
  "ionBlur",
  "ionFocus",
  "ionStyle"
], "value", "v-ion-change", "ionChange");
var IonSegment = defineContainer("ion-segment", defineCustomElement57, [
  "color",
  "disabled",
  "scrollable",
  "swipeGesture",
  "value",
  "selectOnFocus",
  "ionChange",
  "ionSelect",
  "ionStyle"
], "value", "v-ion-change", "ionChange");
var IonSegmentButton = defineContainer("ion-segment-button", defineCustomElement58, [
  "disabled",
  "layout",
  "type",
  "value"
], "value", "v-ion-change", "ionChange");
var IonSelect = defineContainer("ion-select", defineCustomElement59, [
  "disabled",
  "cancelText",
  "okText",
  "placeholder",
  "name",
  "selectedText",
  "multiple",
  "interface",
  "interfaceOptions",
  "compareWith",
  "value",
  "ionChange",
  "ionCancel",
  "ionDismiss",
  "ionFocus",
  "ionBlur",
  "ionStyle"
], "value", "v-ion-change", "ionChange");
var IonSelectOption = defineContainer("ion-select-option", defineCustomElement60, [
  "disabled",
  "value"
]);
var IonSkeletonText = defineContainer("ion-skeleton-text", defineCustomElement61, [
  "animated"
]);
var IonSlide = defineContainer("ion-slide", defineCustomElement62);
var IonSlides = defineContainer("ion-slides", defineCustomElement63, [
  "options",
  "pager",
  "scrollbar",
  "ionSlidesDidLoad",
  "ionSlideTap",
  "ionSlideDoubleTap",
  "ionSlideWillChange",
  "ionSlideDidChange",
  "ionSlideNextStart",
  "ionSlidePrevStart",
  "ionSlideNextEnd",
  "ionSlidePrevEnd",
  "ionSlideTransitionStart",
  "ionSlideTransitionEnd",
  "ionSlideDrag",
  "ionSlideReachStart",
  "ionSlideReachEnd",
  "ionSlideTouchStart",
  "ionSlideTouchEnd"
]);
var IonSpinner = defineContainer("ion-spinner", defineCustomElement64, [
  "color",
  "duration",
  "name",
  "paused"
]);
var IonSplitPane = defineContainer("ion-split-pane", defineCustomElement65, [
  "contentId",
  "disabled",
  "when",
  "ionSplitPaneVisible"
]);
var IonText = defineContainer("ion-text", defineCustomElement66, [
  "color"
]);
var IonTextarea = defineContainer("ion-textarea", defineCustomElement67, [
  "fireFocusEvents",
  "color",
  "autocapitalize",
  "autofocus",
  "clearOnEdit",
  "debounce",
  "disabled",
  "inputmode",
  "enterkeyhint",
  "maxlength",
  "minlength",
  "name",
  "placeholder",
  "readonly",
  "required",
  "spellcheck",
  "cols",
  "rows",
  "wrap",
  "autoGrow",
  "value",
  "ionChange",
  "ionInput",
  "ionStyle",
  "ionBlur",
  "ionFocus"
], "value", "v-ion-change", "ionChange");
var IonThumbnail = defineContainer("ion-thumbnail", defineCustomElement68);
var IonTitle = defineContainer("ion-title", defineCustomElement69, [
  "color",
  "size",
  "ionStyle"
]);
var IonToggle = defineContainer("ion-toggle", defineCustomElement70, [
  "color",
  "name",
  "checked",
  "disabled",
  "value",
  "enableOnOffLabels",
  "ionChange",
  "ionFocus",
  "ionBlur",
  "ionStyle"
], "checked", "v-ion-change", "ionChange");
var IonToolbar = defineContainer("ion-toolbar", defineCustomElement71, [
  "color"
]);
var IonVirtualScroll = defineContainer("ion-virtual-scroll", defineCustomElement72, [
  "approxItemHeight",
  "approxHeaderHeight",
  "approxFooterHeight",
  "headerFn",
  "footerFn",
  "items",
  "itemHeight",
  "headerHeight",
  "footerHeight",
  "renderItem",
  "renderHeader",
  "renderFooter",
  "nodeRender",
  "domRender"
]);
var useBackButton = (priority, handler) => {
  const callback = (ev) => ev.detail.register(priority, handler);
  const unregister = () => document.removeEventListener("ionBackButton", callback);
  document.addEventListener("ionBackButton", callback);
  return { unregister };
};
var useKeyboard = () => {
  let isOpen = ref(false);
  let keyboardHeight = ref(0);
  const showCallback = (ev) => {
    isOpen.value = true;
    keyboardHeight.value = ev.detail.keyboardHeight;
  };
  const hideCallback = () => {
    isOpen.value = false;
    keyboardHeight.value = 0;
  };
  const unregister = () => {
    if (typeof window !== "undefined") {
      window.removeEventListener("ionKeyboardDidShow", showCallback);
      window.removeEventListener("ionKeyboardDidHide", hideCallback);
    }
  };
  if (typeof window !== "undefined") {
    window.addEventListener("ionKeyboardDidShow", showCallback);
    window.addEventListener("ionKeyboardDidHide", hideCallback);
  }
  return {
    isOpen,
    keyboardHeight,
    unregister
  };
};
var LifecycleHooks;
(function(LifecycleHooks2) {
  LifecycleHooks2["WillEnter"] = "onIonViewWillEnter";
  LifecycleHooks2["DidEnter"] = "onIonViewDidEnter";
  LifecycleHooks2["WillLeave"] = "onIonViewWillLeave";
  LifecycleHooks2["DidLeave"] = "onIonViewDidLeave";
})(LifecycleHooks || (LifecycleHooks = {}));
var hookNames = {
  [LIFECYCLE_WILL_ENTER]: LifecycleHooks.WillEnter,
  [LIFECYCLE_DID_ENTER]: LifecycleHooks.DidEnter,
  [LIFECYCLE_WILL_LEAVE]: LifecycleHooks.WillLeave,
  [LIFECYCLE_DID_LEAVE]: LifecycleHooks.DidLeave
};
var ids = { main: 0 };
var generateId = (type = "main") => {
  var _a;
  const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
  ids[type] = id;
  return id.toString();
};
var fireLifecycle = (vueComponent, vueInstance, lifecycle) => {
  if (vueComponent === null || vueComponent === void 0 ? void 0 : vueComponent[lifecycle]) {
    vueComponent[lifecycle].bind(vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value)();
  }
  const instance = vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.value;
  if (instance === null || instance === void 0 ? void 0 : instance[lifecycle]) {
    instance[lifecycle]();
  }
  if (instance) {
    const hook = hookNames[lifecycle];
    const hooks = instance[hook];
    if (hooks) {
      hooks.forEach((hook2) => hook2());
    }
  }
};
var getConfig = () => {
  if (typeof window !== "undefined") {
    const Ionic = window.Ionic;
    if (Ionic && Ionic.config) {
      return Ionic.config;
    }
  }
  return null;
};
var injectHook = (lifecycleType, hook, component) => {
  if (component) {
    const target = component;
    const hooks = target.proxy[lifecycleType] || (target.proxy[lifecycleType] = []);
    if (target.exposed) {
      target.exposed[lifecycleType] = hooks;
    }
    const wrappedHook = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      return args ? hook(...args) : hook();
    };
    hooks.push(wrappedHook);
    return wrappedHook;
  } else {
    console.warn("[@ionic/vue]: Ionic Lifecycle Hooks can only be used during execution of setup().");
  }
};
var createHook = (lifecycle) => {
  return (hook, target = getCurrentInstance()) => injectHook(lifecycle, hook, target);
};
var onIonViewWillEnter = createHook(LifecycleHooks.WillEnter);
var onIonViewDidEnter = createHook(LifecycleHooks.DidEnter);
var onIonViewWillLeave = createHook(LifecycleHooks.WillLeave);
var onIonViewDidLeave = createHook(LifecycleHooks.DidLeave);
var useIonRouter = () => {
  const { canGoBack, goBack, goForward, handleNavigate } = inject("navManager");
  const navigate = (location, routerDirection, routerAction, routerAnimation) => handleNavigate(location, routerAction, routerDirection, routerAnimation);
  const push = (location, routerAnimation) => navigate(location, "forward", "push", routerAnimation);
  const replace = (location, routerAnimation) => navigate(location, "root", "replace", routerAnimation);
  const back = (routerAnimation) => goBack(routerAnimation);
  const forward = (routerAnimation) => goForward(routerAnimation);
  return {
    canGoBack,
    push,
    replace,
    back,
    forward,
    navigate
  };
};
var toKebabCase = (eventName) => eventName === "ionChange" ? "v-ion-change" : eventName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
var getHelperFunctions = () => {
  return {
    ael: (el, eventName, cb, opts) => el.addEventListener(toKebabCase(eventName), cb, opts),
    rel: (el, eventName, cb, opts) => el.removeEventListener(toKebabCase(eventName), cb, opts),
    ce: (eventName, opts) => new CustomEvent(toKebabCase(eventName), opts)
  };
};
var IonicVue = {
  async install(_, config = {}) {
    if (typeof document !== "undefined") {
      document.documentElement.classList.add("ion-ce");
    }
    const { ael, rel, ce } = getHelperFunctions();
    initialize(Object.assign(Object.assign({}, config), { _ael: ael, _rel: rel, _ce: ce }));
  }
};
var IonBackButton = defineComponent((_, { attrs, slots }) => {
  defineCustomElement76();
  const ionRouter = inject("navManager");
  const onClick = () => {
    if (ionRouter === void 0) {
      return;
    }
    const defaultHref = attrs["default-href"] || attrs["defaultHref"];
    const routerAnimation = attrs["router-animation"] || attrs["routerAnimation"];
    ionRouter.handleNavigateBack(defaultHref, routerAnimation);
  };
  return () => {
    return h("ion-back-button", Object.assign({ onClick }, attrs), slots.default && slots.default());
  };
});
var IonPage = defineComponent({
  name: "IonPage",
  props: {
    registerIonPage: { type: Function, default: () => {
    } }
  },
  mounted() {
    this.$props.registerIonPage(this.$refs.ionPage);
  },
  setup(_, { attrs, slots }) {
    return () => {
      return h("div", Object.assign(Object.assign({}, attrs), { ["class"]: "ion-page", ref: "ionPage" }), slots.default && slots.default());
    };
  }
});
var isViewVisible = (enteringEl) => {
  return !enteringEl.classList.contains("ion-page-hidden") && !enteringEl.classList.contains("ion-page-invisible");
};
var viewDepthKey = Symbol(0);
var IonRouterOutlet = defineComponent({
  name: "IonRouterOutlet",
  setup() {
    defineCustomElement81();
    const injectedRoute = inject(routeLocationKey);
    const route = useRoute();
    const depth = inject(viewDepthKey, 0);
    const matchedRouteRef = computed(() => route.matched[depth]);
    let previousMatchedRouteRef;
    let previousMatchedPath;
    provide(viewDepthKey, depth + 1);
    provide(matchedRouteKey, matchedRouteRef);
    const ionRouterOutlet = ref();
    const id = generateId("ion-router-outlet");
    const ionRouter = inject("navManager");
    const viewStacks = inject("viewStacks");
    const components = shallowRef([]);
    let skipTransition = false;
    let parentOutletPath;
    watch(() => [route, matchedRouteRef.value], ([currentRoute, currentMatchedRouteRef]) => {
      if (currentMatchedRouteRef !== void 0) {
        const matchedDifferentRoutes = currentMatchedRouteRef !== previousMatchedRouteRef;
        const matchedDifferentParameterRoutes = currentRoute.matched[currentRoute.matched.length - 1] === currentMatchedRouteRef && currentRoute.path !== previousMatchedPath;
        if (matchedDifferentRoutes || matchedDifferentParameterRoutes) {
          setupViewItem(matchedRouteRef);
        }
      }
      previousMatchedRouteRef = currentMatchedRouteRef;
      previousMatchedPath = currentRoute.path;
    });
    const canStart = () => {
      const config = getConfig();
      const swipeEnabled = config && config.get("swipeBackEnabled", ionRouterOutlet.value.mode === "ios");
      if (!swipeEnabled)
        return false;
      const stack = viewStacks.getViewStack(id);
      if (!stack || stack.length <= 1)
        return false;
      const routeInfo = ionRouter.getLeavingRouteInfo();
      const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || "" }, id);
      return !!enteringViewItem;
    };
    const onStart = async () => {
      const routeInfo = ionRouter.getLeavingRouteInfo();
      const { routerAnimation } = routeInfo;
      const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || "" }, id);
      const leavingViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);
      if (leavingViewItem) {
        let animationBuilder = routerAnimation;
        const enteringEl = enteringViewItem.ionPageElement;
        const leavingEl = leavingViewItem.ionPageElement;
        const customAnimation = enteringViewItem.routerAnimation;
        if (animationBuilder === void 0 && customAnimation !== void 0) {
          animationBuilder = customAnimation;
        }
        leavingViewItem.routerAnimation = animationBuilder;
        await transition(enteringEl, leavingEl, "back", ionRouter.canGoBack(2), true, animationBuilder);
      }
      return Promise.resolve();
    };
    const onEnd = (shouldContinue) => {
      if (shouldContinue) {
        skipTransition = true;
        ionRouter.handleNavigateBack();
      } else {
        const routeInfo = ionRouter.getCurrentRouteInfo();
        const enteringViewItem = viewStacks.findViewItemByRouteInfo({ pathname: routeInfo.pushedByRoute || "" }, id);
        enteringViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        enteringViewItem.ionPageElement.classList.add("ion-page-hidden");
      }
    };
    watch(ionRouterOutlet, () => {
      ionRouterOutlet.value.swipeHandler = {
        canStart,
        onStart,
        onEnd
      };
    });
    const transition = (enteringEl, leavingEl, direction, showGoBack, progressAnimation, animationBuilder) => {
      return new Promise((resolve) => {
        if (skipTransition) {
          skipTransition = false;
          return resolve(false);
        }
        if (enteringEl === leavingEl) {
          return resolve(false);
        }
        requestAnimationFrame(() => {
          requestAnimationFrame(async () => {
            enteringEl.classList.add("ion-page-invisible");
            const hasRootDirection = direction === void 0 || direction === "root" || direction === "none";
            const result = await ionRouterOutlet.value.commit(enteringEl, leavingEl, {
              deepWait: true,
              duration: hasRootDirection && animationBuilder === void 0 ? 0 : void 0,
              direction,
              showGoBack,
              progressAnimation,
              animationBuilder
            });
            return resolve(result);
          });
        });
      });
    };
    const handlePageTransition = async () => {
      const routeInfo = ionRouter.getCurrentRouteInfo();
      const { routerDirection, routerAction, routerAnimation, prevRouteLastPathname, delta } = routeInfo;
      const enteringViewItem = viewStacks.findViewItemByRouteInfo(routeInfo, id);
      let leavingViewItem = viewStacks.findLeavingViewItemByRouteInfo(routeInfo, id);
      const enteringEl = enteringViewItem.ionPageElement;
      if (enteringEl === void 0) {
        console.warn(`[@ionic/vue Warning]: The view you are trying to render for path ${routeInfo.pathname} does not have the required <ion-page> component. Transitions and lifecycle methods may not work as expected.

See https://ionicframework.com/docs/vue/navigation#ionpage for more information.`);
      }
      if (enteringViewItem === leavingViewItem)
        return;
      if (!leavingViewItem && prevRouteLastPathname) {
        leavingViewItem = viewStacks.findViewItemByPathname(prevRouteLastPathname, id);
      }
      if (isViewVisible(enteringEl) && (leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement) !== void 0 && !isViewVisible(leavingViewItem.ionPageElement)) {
        return;
      }
      fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_WILL_ENTER);
      if ((leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement) && enteringViewItem !== leavingViewItem) {
        let animationBuilder = routerAnimation;
        const leavingEl = leavingViewItem.ionPageElement;
        fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_WILL_LEAVE);
        const customAnimation = enteringViewItem.routerAnimation;
        if (animationBuilder === void 0 && routerDirection === "back" && customAnimation !== void 0) {
          animationBuilder = customAnimation;
        }
        leavingViewItem.routerAnimation = animationBuilder;
        await transition(enteringEl, leavingEl, routerDirection, !!routeInfo.pushedByRoute, false, animationBuilder);
        leavingEl.classList.add("ion-page-hidden");
        leavingEl.setAttribute("aria-hidden", "true");
        const usingLinearNavigation = viewStacks.size() === 1;
        if (routerAction === "replace") {
          leavingViewItem.mount = false;
          leavingViewItem.ionPageElement = void 0;
          leavingViewItem.ionRoute = false;
        } else if (!(routerAction === "push" && routerDirection === "forward")) {
          const shouldLeavingViewBeRemoved = routerDirection !== "none" && leavingViewItem && enteringViewItem !== leavingViewItem;
          if (shouldLeavingViewBeRemoved) {
            leavingViewItem.mount = false;
            leavingViewItem.ionPageElement = void 0;
            leavingViewItem.ionRoute = false;
            if (usingLinearNavigation) {
              viewStacks.unmountLeavingViews(id, enteringViewItem, delta);
            }
          }
        } else if (usingLinearNavigation) {
          viewStacks.mountIntermediaryViews(id, leavingViewItem, delta);
        }
        fireLifecycle(leavingViewItem.vueComponent, leavingViewItem.vueComponentRef, LIFECYCLE_DID_LEAVE);
      } else {
        requestAnimationFrame(() => enteringEl.classList.remove("ion-page-invisible"));
      }
      fireLifecycle(enteringViewItem.vueComponent, enteringViewItem.vueComponentRef, LIFECYCLE_DID_ENTER);
      components.value = viewStacks.getChildrenToRender(id);
    };
    const setupViewItem = (matchedRouteRef2) => {
      const firstMatchedRoute = route.matched[0];
      if (!parentOutletPath) {
        parentOutletPath = firstMatchedRoute.path;
      }
      if (!matchedRouteRef2.value || matchedRouteRef2.value !== firstMatchedRoute && firstMatchedRoute.path !== parentOutletPath) {
        return;
      }
      const currentRoute = ionRouter.getCurrentRouteInfo();
      let enteringViewItem = viewStacks.findViewItemByRouteInfo(currentRoute, id);
      if (!enteringViewItem) {
        enteringViewItem = viewStacks.createViewItem(id, matchedRouteRef2.value.components.default, matchedRouteRef2.value, currentRoute);
        viewStacks.add(enteringViewItem);
      }
      if (!enteringViewItem.mount) {
        enteringViewItem.mount = true;
        enteringViewItem.registerCallback = () => {
          handlePageTransition();
          enteringViewItem.registerCallback = void 0;
        };
      } else {
        handlePageTransition();
      }
      components.value = viewStacks.getChildrenToRender(id);
    };
    if (matchedRouteRef.value) {
      setupViewItem(matchedRouteRef);
    }
    onUnmounted(() => viewStacks.clear(id));
    const registerIonPage = (viewItem, ionPageEl) => {
      const oldIonPageEl = viewItem.ionPageElement;
      viewStacks.registerIonPage(viewItem, ionPageEl);
      if (viewItem.registerCallback) {
        ionPageEl.classList.add("ion-page-invisible");
        viewItem.registerCallback();
      } else if (oldIonPageEl && !oldIonPageEl.classList.contains("ion-page-invisible")) {
        ionPageEl.classList.remove("ion-page-invisible");
      }
    };
    return {
      id,
      components,
      injectedRoute,
      ionRouterOutlet,
      registerIonPage
    };
  },
  render() {
    const { components, registerIonPage, injectedRoute } = this;
    return h("ion-router-outlet", { ref: "ionRouterOutlet" }, components && components.map((c) => {
      var _a, _b;
      let props = {
        ref: c.vueComponentRef,
        key: c.pathname,
        registerIonPage: (ionPageEl) => registerIonPage(c, ionPageEl)
      };
      const routePropsOption = (_b = (_a = c.matchedRoute) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.default;
      const getPropsFunctionResult = () => {
        var _a2;
        const cachedPropsResult = (_a2 = c.vueComponentData) === null || _a2 === void 0 ? void 0 : _a2.propsFunctionResult;
        if (cachedPropsResult) {
          return cachedPropsResult;
        } else {
          const propsFunctionResult = routePropsOption(injectedRoute);
          c.vueComponentData = Object.assign(Object.assign({}, c.vueComponentData), { propsFunctionResult });
          return propsFunctionResult;
        }
      };
      const routeProps = routePropsOption ? routePropsOption === true ? c.params : typeof routePropsOption === "function" ? getPropsFunctionResult() : routePropsOption : null;
      props = Object.assign(Object.assign({}, props), routeProps);
      return h(c.vueComponent, props);
    }));
  }
});
var IonTabButton = defineComponent({
  name: "IonTabButton",
  props: {
    _getTabState: { type: Function, default: () => {
      return {};
    } },
    disabled: Boolean,
    download: String,
    href: String,
    rel: String,
    layout: String,
    selected: Boolean,
    tab: String,
    target: String
  },
  setup(props, { slots }) {
    defineCustomElement83();
    const ionRouter = inject("navManager");
    const onClick = (ev) => {
      if (ev.cancelable) {
        ev.preventDefault();
      }
      const { tab, href, _getTabState } = props;
      const tabState = _getTabState();
      const tappedTab = tabState.tabs[tab] || {};
      const originalHref = tappedTab.originalHref || href;
      const currentHref = tappedTab.currentHref || href;
      const prevActiveTab = tabState.activeTab;
      if (prevActiveTab === tab) {
        if (originalHref !== currentHref) {
          ionRouter.resetTab(tab);
        }
      } else {
        ionRouter.changeTab(tab, currentHref);
      }
    };
    return () => {
      return h("ion-tab-button", Object.assign({ onClick }, props), slots.default && slots.default());
    };
  }
});
var WILL_CHANGE = "ionTabsWillChange";
var DID_CHANGE = "ionTabsDidChange";
var IonTabs = defineComponent({
  name: "IonTabs",
  emits: [WILL_CHANGE, DID_CHANGE],
  render() {
    var _a;
    const { $slots: slots, $emit } = this;
    const slottedContent = slots.default && slots.default();
    let routerOutlet;
    if (slottedContent && slottedContent.length > 0) {
      routerOutlet = slottedContent.find((child) => child.type && child.type.name === "IonRouterOutlet");
    }
    if (!routerOutlet) {
      throw new Error("IonTabs must contain an IonRouterOutlet. See https://ionicframework.com/docs/vue/navigation#working-with-tabs for more information.");
    }
    let childrenToRender = [
      h("div", {
        class: "tabs-inner",
        style: {
          "position": "relative",
          "flex": "1",
          "contain": "layout size style"
        }
      }, routerOutlet)
    ];
    if (slottedContent && slottedContent.length > 0) {
      const filteredContent = slottedContent.filter((child) => !child.type || child.type && child.type.name !== "IonRouterOutlet");
      const slottedTabBar = filteredContent.find((child) => child.type && child.type.name === "IonTabBar");
      const hasTopSlotTabBar = slottedTabBar && ((_a = slottedTabBar.props) === null || _a === void 0 ? void 0 : _a.slot) === "top";
      if (slottedTabBar) {
        if (!slottedTabBar.props) {
          slottedTabBar.props = {};
        }
        slottedTabBar.props._tabsWillChange = (tab) => $emit(WILL_CHANGE, { tab });
        slottedTabBar.props._tabsDidChange = (tab) => $emit(DID_CHANGE, { tab });
      }
      if (hasTopSlotTabBar) {
        childrenToRender = [
          ...filteredContent,
          ...childrenToRender
        ];
      } else {
        childrenToRender = [
          ...childrenToRender,
          ...filteredContent
        ];
      }
    }
    return h("ion-tabs", {
      style: {
        "display": "flex",
        "position": "absolute",
        "top": "0",
        "left": "0",
        "right": "0",
        "bottom": "0",
        "flex-direction": "column",
        "width": "100%",
        "height": "100%",
        "contain": "layout size style",
        "z-index": "0"
      }
    }, childrenToRender);
  }
});
var isTabButton = (child) => {
  var _a;
  return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === "IonTabButton";
};
var getTabs = (nodes) => {
  let tabs = [];
  nodes.forEach((node) => {
    if (isTabButton(node)) {
      tabs.push(node);
    } else if (Array.isArray(node.children) && node.children.length > 1) {
      const childTabs = getTabs(node.children);
      tabs = [...tabs, ...childTabs];
    }
  });
  return tabs;
};
var IonTabBar = defineComponent({
  name: "IonTabBar",
  props: {
    _tabsWillChange: { type: Function, default: () => {
    } },
    _tabsDidChange: { type: Function, default: () => {
    } }
  },
  data() {
    return {
      tabState: {
        activeTab: void 0,
        tabs: {}
      },
      tabVnodes: []
    };
  },
  updated() {
    this.setupTabState(inject("navManager"));
  },
  methods: {
    setupTabState(ionRouter) {
      const tabState = this.$data.tabState;
      const currentInstance = getCurrentInstance();
      const tabs = this.$data.tabVnodes = getTabs(currentInstance.subTree.children || []);
      tabs.forEach((child) => {
        tabState.tabs[child.props.tab] = {
          originalHref: child.props.href,
          currentHref: child.props.href,
          ref: child
        };
        child.component.props._getTabState = () => tabState;
      });
      this.checkActiveTab(ionRouter);
    },
    checkActiveTab(ionRouter) {
      const currentRoute = ionRouter.getCurrentRouteInfo();
      const childNodes = this.$data.tabVnodes;
      const { tabs, activeTab: prevActiveTab } = this.$data.tabState;
      const tabState = this.$data.tabState;
      const tabKeys = Object.keys(tabs);
      const activeTab = tabKeys.find((key) => {
        const href = tabs[key].originalHref;
        return currentRoute.pathname.startsWith(href);
      });
      childNodes.forEach((child) => {
        const tab = tabs[child.props.tab];
        if (!tab || tab.originalHref !== child.props.href) {
          tabs[child.props.tab] = {
            originalHref: child.props.href,
            currentHref: child.props.href,
            ref: child
          };
        }
      });
      if (activeTab && prevActiveTab) {
        const prevHref = this.$data.tabState.tabs[prevActiveTab].currentHref;
        if (activeTab !== prevActiveTab || prevHref !== currentRoute.pathname) {
          const search = currentRoute.search ? `?${currentRoute.search}` : "";
          tabs[activeTab] = Object.assign(Object.assign({}, tabs[activeTab]), { currentHref: currentRoute.pathname + search });
        }
        if (currentRoute.routerAction === "pop" && activeTab !== prevActiveTab) {
          tabs[prevActiveTab] = Object.assign(Object.assign({}, tabs[prevActiveTab]), { currentHref: tabs[prevActiveTab].originalHref });
        }
      }
      const activeChild = childNodes.find((child) => {
        var _a;
        return isTabButton(child) && ((_a = child.props) === null || _a === void 0 ? void 0 : _a.tab) === activeTab;
      });
      const tabBar = this.$refs.ionTabBar;
      const tabDidChange = activeTab !== prevActiveTab;
      if (tabBar) {
        if (activeChild) {
          tabDidChange && this.$props._tabsWillChange(activeTab);
          ionRouter.handleSetCurrentTab(activeTab);
          tabBar.selectedTab = tabState.activeTab = activeTab;
          tabDidChange && this.$props._tabsDidChange(activeTab);
        } else {
          tabBar.selectedTab = tabState.activeTab = "";
        }
      }
    }
  },
  mounted() {
    const ionRouter = inject("navManager");
    this.setupTabState(ionRouter);
    ionRouter.registerHistoryChangeListener(() => this.checkActiveTab(ionRouter));
  },
  setup(_, { slots }) {
    defineCustomElement82();
    return () => {
      return h("ion-tab-bar", { ref: "ionTabBar" }, slots.default && slots.default());
    };
  }
});
var userComponents = shallowRef([]);
var IonApp = defineComponent((_, { attrs, slots }) => {
  defineCustomElement75();
  return () => {
    return h("ion-app", Object.assign({}, attrs), [slots.default && slots.default(), ...userComponents.value]);
  };
});
var addTeleportedUserComponent = (component) => {
  userComponents.value = [
    ...userComponents.value,
    component
  ];
};
var removeTeleportedUserComponent = (component) => {
  userComponents.value = userComponents.value.filter((cmp) => cmp !== component);
};
var VueDelegate = (addFn = addTeleportedUserComponent, removeFn = removeTeleportedUserComponent) => {
  let Component;
  const attachViewToDom = (parentElement, component, componentProps = {}, classes) => {
    delete componentProps["modal"];
    delete componentProps["popover"];
    const div = document.createElement("div");
    classes && div.classList.add(...classes);
    parentElement.appendChild(div);
    Component = h(Teleport, { to: div }, h(component, Object.assign({}, componentProps)));
    addFn(Component);
    return Promise.resolve(div);
  };
  const removeViewFromDom = () => {
    Component && removeFn(Component);
    return Promise.resolve();
  };
  return { attachViewToDom, removeViewFromDom };
};
var IonNav = defineComponent(() => {
  defineCustomElement43();
  const views = shallowRef([]);
  const addView = (component) => views.value = [...views.value, component];
  const removeView = (component) => views.value = views.value.filter((cmp) => cmp !== component);
  const delegate = VueDelegate(addView, removeView);
  return () => {
    return h("ion-nav", { delegate }, views.value);
  };
});
var IonIcon = defineComponent({
  name: "IonIcon",
  props: {
    color: String,
    flipRtl: Boolean,
    icon: String,
    ios: String,
    lazy: String,
    md: String,
    mode: String,
    name: String,
    size: String,
    src: String
  },
  setup(props, { slots }) {
    defineCustomElement85();
    return () => {
      var _a, _b;
      const { icon, ios, md } = props;
      let iconToUse;
      if (ios || md) {
        if (isPlatform("ios")) {
          iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
        } else {
          iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
        }
      } else {
        iconToUse = icon;
      }
      return h("ion-icon", Object.assign(Object.assign({}, props), { icon: iconToUse }), slots);
    };
  }
});
var EMPTY_PROP$1 = Symbol();
var DEFAULT_EMPTY_PROP$1 = { default: EMPTY_PROP$1 };
var defineOverlayContainer = (name, defineCustomElement86, componentProps = [], controller) => {
  const createControllerComponent = () => {
    return defineComponent((props, { slots, emit }) => {
      const eventListeners = [
        { componentEv: `${name}-will-present`, frameworkEv: "willPresent" },
        { componentEv: `${name}-did-present`, frameworkEv: "didPresent" },
        { componentEv: `${name}-will-dismiss`, frameworkEv: "willDismiss" },
        { componentEv: `${name}-did-dismiss`, frameworkEv: "didDismiss" }
      ];
      if (defineCustomElement86 !== void 0) {
        defineCustomElement86();
      }
      const overlay = ref();
      const onVnodeMounted = async () => {
        const isOpen = props.isOpen;
        isOpen && await present(props);
      };
      const onVnodeUpdated = async (node, prevNode) => {
        const isOpen = node.props.isOpen;
        const prevIsOpen = prevNode.props.isOpen;
        if (isOpen === prevIsOpen)
          return;
        if (isOpen) {
          await present(props);
        } else {
          await dismiss();
        }
      };
      const onVnodeBeforeUnmount = async () => {
        await dismiss();
      };
      const dismiss = async () => {
        if (!overlay.value)
          return;
        await overlay.value;
        overlay.value = overlay.value.dismiss();
        await overlay.value;
        overlay.value = void 0;
      };
      const present = async (props2) => {
        var _a;
        if (overlay.value) {
          await overlay.value;
        }
        if ((_a = overlay.value) === null || _a === void 0 ? void 0 : _a.present) {
          await overlay.value.present();
          return;
        }
        let restOfProps = {};
        for (const key in props2) {
          const value = props2[key];
          if (props2.hasOwnProperty(key) && value !== EMPTY_PROP$1) {
            restOfProps[key] = value;
          }
        }
        delete restOfProps.onWillPresent;
        delete restOfProps.onDidPresent;
        delete restOfProps.onWillDismiss;
        delete restOfProps.onDidDismiss;
        const component = slots.default && slots.default()[0];
        overlay.value = controller.create(Object.assign(Object.assign({}, restOfProps), { component }));
        overlay.value = await overlay.value;
        eventListeners.forEach((eventListener) => {
          overlay.value.addEventListener(eventListener.componentEv, () => {
            emit(eventListener.frameworkEv);
          });
        });
        await overlay.value.present();
      };
      return () => {
        return h("div", {
          style: { display: "none" },
          onVnodeMounted,
          onVnodeUpdated,
          onVnodeBeforeUnmount,
          isOpen: props.isOpen === true
        });
      };
    });
  };
  const createInlineComponent = () => {
    return defineComponent((props, { slots }) => {
      if (defineCustomElement86 !== void 0) {
        defineCustomElement86();
      }
      const isOpen = ref(false);
      const elementRef = ref();
      onMounted(() => {
        elementRef.value.addEventListener("ion-mount", () => isOpen.value = true);
        elementRef.value.addEventListener("will-present", () => isOpen.value = true);
        elementRef.value.addEventListener("did-dismiss", () => isOpen.value = false);
      });
      return () => {
        let restOfProps = {};
        for (const key in props) {
          const value = props[key];
          if (props.hasOwnProperty(key) && value !== EMPTY_PROP$1) {
            restOfProps[key] = value;
          }
        }
        return h(name, Object.assign(Object.assign({}, restOfProps), { ref: elementRef }), isOpen.value || restOfProps.keepContentsMounted ? slots : void 0);
      };
    });
  };
  const Container = controller !== void 0 ? createControllerComponent() : createInlineComponent();
  Container.displayName = name;
  Container.props = {
    "isOpen": DEFAULT_EMPTY_PROP$1
  };
  componentProps.forEach((componentProp) => {
    Container.props[componentProp] = DEFAULT_EMPTY_PROP$1;
  });
  if (controller !== void 0) {
    Container.emits = ["willPresent", "didPresent", "willDismiss", "didDismiss"];
  }
  return Container;
};
var IonActionSheet = defineOverlayContainer("ion-action-sheet", defineCustomElement73, ["animated", "backdropDismiss", "buttons", "cssClass", "enterAnimation", "header", "htmlAttributes", "keyboardClose", "leaveAnimation", "mode", "subHeader", "translucent"], actionSheetController);
var IonAlert = defineOverlayContainer("ion-alert", defineCustomElement74, ["animated", "backdropDismiss", "buttons", "cssClass", "enterAnimation", "header", "htmlAttributes", "inputs", "keyboardClose", "leaveAnimation", "message", "mode", "subHeader", "translucent"], alertController);
var IonLoading = defineOverlayContainer("ion-loading", defineCustomElement77, ["animated", "backdropDismiss", "cssClass", "duration", "enterAnimation", "htmlAttributes", "keyboardClose", "leaveAnimation", "message", "mode", "showBackdrop", "spinner", "translucent"], loadingController);
var IonPicker = defineOverlayContainer("ion-picker", defineCustomElement79, ["animated", "backdropDismiss", "buttons", "columns", "cssClass", "duration", "enterAnimation", "htmlAttributes", "keyboardClose", "leaveAnimation", "mode", "showBackdrop"], pickerController);
var IonToast = defineOverlayContainer("ion-toast", defineCustomElement84, ["animated", "buttons", "color", "cssClass", "duration", "enterAnimation", "header", "htmlAttributes", "icon", "keyboardClose", "leaveAnimation", "message", "mode", "position", "translucent"], toastController);
var IonModal = defineOverlayContainer("ion-modal", defineCustomElement78, ["animated", "backdropBreakpoint", "backdropDismiss", "breakpoints", "canDismiss", "enterAnimation", "handle", "handleBehavior", "htmlAttributes", "initialBreakpoint", "isOpen", "keepContentsMounted", "keyboardClose", "leaveAnimation", "mode", "presentingElement", "showBackdrop", "swipeToClose", "trigger"]);
var IonPopover = defineOverlayContainer("ion-popover", defineCustomElement80, ["alignment", "animated", "arrow", "backdropDismiss", "component", "componentProps", "dismissOnSelect", "enterAnimation", "event", "htmlAttributes", "isOpen", "keepContentsMounted", "keyboardClose", "leaveAnimation", "mode", "reference", "showBackdrop", "side", "size", "translucent", "trigger", "triggerAction"]);
var createController = (defineCustomElement86, oldController, useDelegate = false) => {
  const delegate = useDelegate ? VueDelegate() : void 0;
  const oldCreate = oldController.create.bind(oldController);
  oldController.create = (options) => {
    defineCustomElement86();
    return oldCreate(Object.assign(Object.assign({}, options), { delegate }));
  };
  return oldController;
};
var modalController2 = createController(defineCustomElement78, modalController, true);
var popoverController2 = createController(defineCustomElement80, popoverController, true);
var alertController2 = createController(defineCustomElement74, alertController);
var actionSheetController2 = createController(defineCustomElement73, actionSheetController);
var loadingController2 = createController(defineCustomElement77, loadingController);
var pickerController2 = createController(defineCustomElement79, pickerController);
var toastController2 = createController(defineCustomElement84, toastController);
export {
  IonAccordion,
  IonAccordionGroup,
  IonActionSheet,
  IonAlert,
  IonApp,
  IonAvatar,
  IonBackButton,
  IonBackdrop,
  IonBadge,
  IonBreadcrumb,
  IonBreadcrumbs,
  IonButton,
  IonButtons,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardSubtitle,
  IonCardTitle,
  IonCheckbox,
  IonChip,
  IonCol,
  IonContent,
  IonDatetime,
  IonDatetimeButton,
  IonFab,
  IonFabButton,
  IonFabList,
  IonFooter,
  IonGrid,
  IonHeader,
  IonIcon,
  IonImg,
  IonInfiniteScroll,
  IonInfiniteScrollContent,
  IonInput,
  IonItem,
  IonItemDivider,
  IonItemGroup,
  IonItemOption,
  IonItemOptions,
  IonItemSliding,
  IonLabel,
  IonList,
  IonListHeader,
  IonLoading,
  IonMenu,
  IonMenuButton,
  IonMenuToggle,
  IonModal,
  IonNav,
  IonNavLink,
  IonNote,
  IonPage,
  IonPicker,
  IonPopover,
  IonProgressBar,
  IonRadio,
  IonRadioGroup,
  IonRange,
  IonRefresher,
  IonRefresherContent,
  IonReorder,
  IonReorderGroup,
  IonRippleEffect,
  IonRouterOutlet,
  IonRow,
  IonSearchbar,
  IonSegment,
  IonSegmentButton,
  IonSelect,
  IonSelectOption,
  IonSkeletonText,
  IonSlide,
  IonSlides,
  IonSpinner,
  IonSplitPane,
  IonTabBar,
  IonTabButton,
  IonTabs,
  IonText,
  IonTextarea,
  IonThumbnail,
  IonTitle,
  IonToast,
  IonToggle,
  IonToolbar,
  IonVirtualScroll,
  IonicSafeString,
  IonicSlides,
  IonicSwiper,
  IonicVue,
  actionSheetController2 as actionSheetController,
  alertController2 as alertController,
  createAnimation,
  createGesture,
  getPlatforms,
  getTimeGivenProgression,
  iosTransitionAnimation,
  isPlatform,
  loadingController2 as loadingController,
  mdTransitionAnimation,
  menuController,
  modalController2 as modalController,
  onIonViewDidEnter,
  onIonViewDidLeave,
  onIonViewWillEnter,
  onIonViewWillLeave,
  pickerController2 as pickerController,
  popoverController2 as popoverController,
  toastController2 as toastController,
  useBackButton,
  useIonRouter,
  useKeyboard
};
//# sourceMappingURL=@ionic_vue.js.map
